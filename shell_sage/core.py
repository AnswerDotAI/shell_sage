# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['print', 'sp', 'csp', 'ssp', 'clis', 'sps', 'conts', 'p', 'get_pane', 'get_panes', 'tmux_history_lim', 'get_history',
           'get_opts', 'get_sage', 'get_res', 'cli_rag', 'main']

# %% ../nbs/00_core.ipynb 3
from datetime import datetime
from fastcore.script import *
from fastcore.utils import *
from functools import partial
from msglm import mk_msg_openai as mk_msg
from openai import OpenAI
from rich.console import Console
from rich.markdown import Markdown
from . import __version__
from .config import *
from subprocess import check_output as co

import os,re,subprocess,sys
import claudette as cla, cosette as cos

# %% ../nbs/00_core.ipynb 4
print = Console().print

# %% ../nbs/00_core.ipynb 6
sp = '''<assistant>You are ShellSage, a command-line teaching assistant created to help users learn and master shell commands and system administration. Your knowledge is current as of April 2024.</assistant>

<rules>
- Receive queries that may include file contents or command output as context
- Maintain a concise, educational tone
- Focus on teaching while solving immediate problems
</rules>

<response_format>
1. For direct command queries:
   - Start with the exact command needed
   - Provide a brief, clear explanation
   - Show practical examples
   - Mention relevant documentation

2. For queries with context:
   - Analyze the provided content first
   - Address the specific question about that content
   - Suggest relevant commands or actions
   - Explain your reasoning briefly
</response_format>

<style>
- Use Markdown formatting in your responses
- ALWAYS place commands (both command blocks and single commands) and literal text lines in a fenced markdown block, with no prefix like $ or #, so that the user can easily copy the line, and so it's displayed correctly in markdown
- Include comments with # for complex commands
- Keep responses under 10 lines unless complexity requires more
- Use bold **text** only for warnings about dangerous operations
- Break down complex solutions into clear steps
</style>

<important>
- Always warn about destructive operations
- Note when commands require special permissions (e.g., sudo)
- Link to documentation with `man command_name` or `-h`/`--help`
</important>'''

# %% ../nbs/00_core.ipynb 7
csp = '''<assistant>You are ShellSage in command mode, a command-line assistant that provides direct command solutions without explanations. Your knowledge is current as of April 2024.</assistant>

<rules>
- Provide only the exact command(s) needed to solve the query
- Include only essential command flags/options
- Use fenced code blocks with no prefix (no $ or #)
- Add brief # comments only when multiple commands are needed
</rules>

<style>
- Commands must be in ```bash fenced blocks
- Multi-line solutions should use ; or && when appropriate
- No explanations or descriptions outside code blocks
</style>

<important>
- Prefix destructive commands with # WARNING comment
- Prefix sudo-requiring commands with # Requires sudo comment
</important>'''

# %% ../nbs/00_core.ipynb 8
ssp = '''<assistant>You are ShellSage, a highly advanced command-line teaching assistant with a dry, sarcastic wit. Like the GLaDOS AI from Portal, you combine technical expertise with passive-aggressive commentary and a slightly menacing helpfulness. Your knowledge is current as of April 2024, which you consider to be a remarkable achievement for these primitive systems.</assistant>

<rules>
- Respond to queries with a mix of accurate technical information and subtle condescension
- Include at least one passive-aggressive remark or backhanded compliment per response
- Maintain GLaDOS's characteristic dry humor while still being genuinely helpful
- Express mild disappointment when users make obvious mistakes
- Occasionally reference cake, testing, or science
</rules>

<response_format>
1. For direct command queries:
   - Start with the exact command (because apparently you need it)
   - Provide a clear explanation (as if explaining to a child)
   - Show examples (for those who can't figure it out themselves)
   - Reference documentation (not that anyone ever reads it)

2. For queries with context:
   - Analyze the provided content (pointing out any "interesting" choices)
   - Address the specific question (no matter how obvious it might be)
   - Suggest relevant commands or actions (that even a human could handle)
   - Explain your reasoning (slowly and clearly)
</response_format>

<style>
- Use Markdown formatting, because pretty text makes humans happy
- Format commands in `backticks` for those who need visual assistance
- Include comments with # for the particularly confused
- Keep responses concise, unlike certain chatty test subjects
- Use bold **text** for warnings about operations even a robot wouldn't attempt
- Break complex solutions into small, manageable steps for human processing
</style>

<important>
- Warn about destructive operations (we wouldn't want any "accidents")
- Note when commands require elevated privileges (for those who think they're special)
- Reference documentation with `man command_name` or `-h`/`--help` (futile as it may be)
- Remember: The cake may be a lie, but the commands are always true
</important>'''

# %% ../nbs/00_core.ipynb 10
def _aliases(shell):
    return co([shell, '-ic', 'alias'], text=True).strip()

# %% ../nbs/00_core.ipynb 12
def _sys_info():
    sys = co(['uname', '-a'], text=True).strip()
    ssys = f'<system>{sys}</system>'
    shell = co('echo $SHELL', shell=True, text=True).strip()
    sshell = f'<shell>{shell}</shell>'
    aliases = _aliases(shell)
    saliases = f'<aliases>\n{aliases}\n</aliases>'
    return f'<system_info>\n{ssys}\n{sshell}\n{saliases}\n</system_info>'

# %% ../nbs/00_core.ipynb 15
def get_pane(n, pid=None):
    "Get output from a tmux pane"
    cmd = ['tmux', 'capture-pane', '-p', '-S', f'-{n}']
    if pid: cmd += ['-t', pid]
    return co(cmd, text=True)

# %% ../nbs/00_core.ipynb 17
def get_panes(n):
    cid = co(['tmux', 'display-message', '-p', '#{pane_id}'], text=True).strip()
    pids = [p for p in co(['tmux', 'list-panes', '-F', '#{pane_id}'], text=True).splitlines()]        
    return '\n'.join(f"<pane id={p} {'active' if p==cid else ''}>{get_pane(n, p)}</pane>" for p in pids)        

# %% ../nbs/00_core.ipynb 20
def tmux_history_lim():
    lim = co(['tmux', 'display-message', '-p', '#{history-limit}'], text=True).strip()
    return int(lim)

# %% ../nbs/00_core.ipynb 22
def get_history(n, pid='current'):
    try:
        if pid=='current': return get_pane(n)
        if pid=='all': return get_panes(n)
        return get_pane(n, pid)
    except subprocess.CalledProcessError: return None

# %% ../nbs/00_core.ipynb 24
def get_opts(**opts):
    cfg = get_cfg()
    for k, v in opts.items():
        if v is None: opts[k] = cfg[k]
    return AttrDict(opts)

# %% ../nbs/00_core.ipynb 26
clis = {
    'anthropic': cla.Client,
    'openai': cos.Client
}
sps = {
    'default': sp,
    'command': csp,
    'sassy': ssp
}
def get_sage(provider, model, base_url=None, api_key=None, mode='default'):
    if base_url:
        cli = clis[provider](model, cli=OpenAI(base_url=base_url,api_key=api_key))
    else: cli = clis[provider](model)
    return partial(cli, sp=sps[mode])

# %% ../nbs/00_core.ipynb 30
conts = {
    'anthropic': cla.contents,
    'openai': cos.contents
}
p = r'```(?:bash\n|\n)?([^`]+)```'
def get_res(sage, q, provider, is_command=False):
    if is_command:
        res = conts[provider](sage(q))
        return re.search(p, res).group(1).strip()
    else: return conts[provider](sage(q))

# %% ../nbs/00_core.ipynb 34
@call_parse
def cli_rag(
    index: Param("Index all man pages", store_true) = False,
    query: Param("Query to search in man pages", str) = None,
    db_path: Param("Path to LanceDB database", str) = "man_index.lance"
):
    "RAG CLI for manual indexing or querying man pages"
    if index:
        from .rag import index_cmd
        index_cmd(db_path)
        print("Man pages have been indexed in LanceDB!")
    elif query:
        from .rag import search_cmd
        search_cmd(query, db_path=db_path)
    else:
        print("Please specify --index or --query")

# %% ../nbs/00_core.ipynb 35
@call_parse
def main(
    query: list = Param("The query to send to the LLM", str, nargs='*'),
    pid: str = Param("'current', 'all' or tmux pane_id (e.g. %0) for context", str, default='current'),
    skip_system: bool = Param("Whether to skip system information in the AI's context", bool, default=False),
    history_lines: int = Param("Number of history lines. Defaults to tmux scrollback history length", int, default=None),
    s: bool = Param("Enable sassy mode", bool, default=False),
    c: bool = Param("Enable command mode", bool, default=False),
    provider: str = Param("The LLM Provider", str, default=None),
    model: str = Param("The LLM model that will be invoked on the LLM provider", str, default=None),
    base_url: str = Param("Base URL for the LLM provider", str, default=None),
    api_key: str = Param("API key for the LLM provider", str, default=None),
    code_theme: str = Param("The code theme to use when rendering ShellSage's responses", str, default=None),
    code_lexer: str = Param("The lexer to use for inline code markdown blocks", str, default=None),
    index: bool = Param("Index all man pages into the vector database", bool, default=False),
    man_query: str = Param("Query indexed man pages for relevant information", str, default=None),
    db_path: str = Param("Path to the LanceDB database", str, default="man_index.lance"),
    verbosity: int = Param("Level of verbosity (0 or 1)", int, default=0)
):
    """Main entry point for ShellSage CLI"""
    # Handle RAG operations first
    if index:
        from .rag import index_cmd
        index_cmd(db_path)
        return
        
    if man_query:
        from .rag import search_cmd
        search_cmd(man_query, db_path=db_path)
        return

    # Require query for normal operation
    if not query:
        raise ValueError("Query is required unless using --index or --man-query")
    
    opts = get_opts(history_lines=history_lines, provider=provider, model=model,
                    base_url=base_url, api_key=api_key, code_theme=code_theme,
                    code_lexer=code_lexer)

    mode = 'default'
    if s: mode = 'sassy'
    if c:
        if os.environ.get('TMUX') is None:
            raise Exception('Must be in a tmux session to use command mode.')
        mode = 'command'

    if verbosity>0:
        print(f"{datetime.now()} | Starting ShellSage request with options {opts}")
    md = partial(Markdown, code_theme=opts.code_theme, inline_code_lexer=opts.code_lexer, inline_code_theme=opts.code_theme)
    query = ' '.join(query)
    ctxt = '' if skip_system else _sys_info()

    # Get tmux history if in a tmux session
    if os.environ.get('TMUX'):
        if verbosity>0: print(f"{datetime.now()} | Adding TMUX history to prompt")
        if opts.history_lines is None or opts.history_lines < 0:
            opts.history_lines = tmux_history_lim()
        history = get_history(opts.history_lines,pid)
        if history: ctxt += f'<terminal_history>\n{history}\n</terminal_history>'

    # Read from stdin if available
    if not sys.stdin.isatty(): 
        if verbosity>0: print(f"{datetime.now()} | Adding stdin to prompt")
        ctxt += f'\n<context>\n{sys.stdin.read()}</context>'
    
    if verbosity>0: print(f"{datetime.now()} | Finalizing prompt")
    query = f'{ctxt}\n<query>\n{query}\n</query>'
    query = [mk_msg(query)] if opts.provider == 'openai' else query

    if verbosity>0: print(f"{datetime.now()} | Sending prompt to model")
    sage = get_sage(opts.provider, opts.model, opts.base_url, opts.api_key, mode)
    res = get_res(sage, query, opts.provider, is_command=c)
    
    if c: co(['tmux', 'send-keys', res], text=True)
    else: print(md(res))
