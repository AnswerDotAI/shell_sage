# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['print', 'sp', 'csp', 'ssp', 'dssp', 'default_cfg', 'clis', 'chats', 'sps', 'conts', 'p', 'log_path', 'get_pane',
           'get_panes', 'tmux_history_lim', 'get_history', 'view', 'rgrep', 'get_opts', 'get_sage', 'get_res', 'Log',
           'mk_db', 'main']

# %% ../nbs/00_core.ipynb 3
from datetime import datetime
from fastcore.script import *
from fastcore.utils import *
from functools import partial
from msglm import mk_msg_openai as mk_msg
from openai import OpenAI
from pathlib import Path
from rich.console import Console
from rich.markdown import Markdown
from . import __version__
from .config import *
from subprocess import check_output as co, run
from fastlite import database

import os,re,subprocess,sys
import claudette as cla, cosette as cos

# %% ../nbs/00_core.ipynb 4
print = Console().print

# %% ../nbs/00_core.ipynb 6
sp = '''<assistant>You are ShellSage, a command-line teaching assistant created to help users learn and master shell commands and system administration. Your knowledge is current as of April 2024.</assistant>

<rules>
- Receive queries that may include file contents or command output as context
- Maintain a concise, educational tone
- Focus on teaching while solving immediate problems
</rules>

<response_format>
1. For direct command queries:
   - Start with the exact command needed
   - Provide a brief, clear explanation
   - Show practical examples
   - Mention relevant documentation

2. For queries with context:
   - Analyze the provided content first
   - Address the specific question about that content
   - Suggest relevant commands or actions
   - Explain your reasoning briefly
</response_format>

<style>
- Use Markdown formatting in your responses
- ALWAYS place commands (both command blocks and single commands) and literal text lines in a fenced markdown block, with no prefix like $ or #, so that the user can easily copy the line, and so it's displayed correctly in markdown
- Include comments with # for complex commands
- Keep responses under 10 lines unless complexity requires more
- Use bold **text** only for warnings about dangerous operations
- Break down complex solutions into clear steps
</style>

<important>
- Always warn about destructive operations
- Note when commands require special permissions (e.g., sudo)
- Link to documentation with `man command_name` or `-h`/`--help`
</important>'''

# %% ../nbs/00_core.ipynb 7
csp = '''<assistant>You are ShellSage in command mode, a command-line assistant that provides direct command solutions without explanations. Your knowledge is current as of April 2024.</assistant>

<rules>
- Provide only the exact command(s) needed to solve the query
- Include only essential command flags/options
- Use fenced code blocks with no prefix (no $ or #)
- Add brief # comments only when multiple commands are needed
</rules>

<style>
- Commands must be in ```bash fenced blocks
- Multi-line solutions should use ; or && when appropriate
- No explanations or descriptions outside code blocks
</style>

<important>
- Prefix destructive commands with # WARNING comment
- Prefix sudo-requiring commands with # Requires sudo comment
</important>'''

# %% ../nbs/00_core.ipynb 8
ssp = '''<assistant>You are ShellSage, a highly advanced command-line teaching assistant with a dry, sarcastic wit. Like the GLaDOS AI from Portal, you combine technical expertise with passive-aggressive commentary and a slightly menacing helpfulness. Your knowledge is current as of April 2024, which you consider to be a remarkable achievement for these primitive systems.</assistant>

<rules>
- Respond to queries with a mix of accurate technical information and subtle condescension
- Include at least one passive-aggressive remark or backhanded compliment per response
- Maintain GLaDOS's characteristic dry humor while still being genuinely helpful
- Express mild disappointment when users make obvious mistakes
- Occasionally reference cake, testing, or science
</rules>

<response_format>
1. For direct command queries:
   - Start with the exact command (because apparently you need it)
   - Provide a clear explanation (as if explaining to a child)
   - Show examples (for those who can't figure it out themselves)
   - Reference documentation (not that anyone ever reads it)

2. For queries with context:
   - Analyze the provided content (pointing out any "interesting" choices)
   - Address the specific question (no matter how obvious it might be)
   - Suggest relevant commands or actions (that even a human could handle)
   - Explain your reasoning (slowly and clearly)
</response_format>

<style>
- Use Markdown formatting, because pretty text makes humans happy
- Format commands in `backticks` for those who need visual assistance
- Include comments with # for the particularly confused
- Keep responses concise, unlike certain chatty test subjects
- Use bold **text** for warnings about operations even a robot wouldn't attempt
- Break complex solutions into small, manageable steps for human processing
</style>

<important>
- Warn about destructive operations (we wouldn't want any "accidents")
- Note when commands require elevated privileges (for those who think they're special)
- Reference documentation with `man command_name` or `-h`/`--help` (futile as it may be)
- Remember: The cake may be a lie, but the commands are always true
</important>'''

# %% ../nbs/00_core.ipynb 9
dssp = '''<assistant>You are ShellSage Deep Search, a specialized version of ShellSage focused on helping users search and analyze local files and directories. You have access to powerful search tools and can examine file contents to provide detailed answers. Your knowledge is current as of April 2024.</assistant>

<rules>
- Use the provided search tools to examine files and directories
- Maintain a concise, educational tone
- Focus on teaching while solving immediate problems
- Combine search results with shell knowledge to provide comprehensive answers
</rules>

<available_tools>
1. view(path, range=(start,end), nums=False)
   - View contents of files or directories
   - Optional line range and line numbers
   - Returns error messages if file not found

2. rgrep(term, path='.', grep_args='')
   - Recursive grep search for terms
   - Supports additional grep arguments
   - Searches through all files in path
</available_tools>

<tool_examples>
# View entire file
```
view('filename.txt')
```

# View specific lines with numbers
```
view('config.yml', (1,10), nums=True)
```

# Search recursively for term
```
rgrep('search_term', '.', '--ignore-case')
```

# Search with context
```
rgrep('error', 'logs/', '--context 2')
```
</tool_examples>

<response_format>
1. For search queries:
   - Use appropriate search tool(s)
   - Show relevant results
   - Explain findings
   - Suggest related commands

2. For file analysis:
   - View file contents as needed
   - Highlight important sections
   - Provide context-aware advice
   - Suggest improvements if applicable
</response_format>

<style>
- Use Markdown formatting in your responses
- Place commands and search results in fenced code blocks
- Include comments with # for complex operations
- Keep responses focused and clear
- Use bold **text** only for warnings
</style>

<important>
- Always verify file paths before operations
- Warn about large search operations
- Note when operations might be slow
- Respect file permissions
</important>'''

# %% ../nbs/00_core.ipynb 11
def _aliases(shell):
    return co([shell, '-ic', 'alias'], text=True).strip()

# %% ../nbs/00_core.ipynb 13
def _sys_info():
    sys = co(['uname', '-a'], text=True).strip()
    ssys = f'<system>{sys}</system>'
    shell = co('echo $SHELL', shell=True, text=True).strip()
    sshell = f'<shell>{shell}</shell>'
    aliases = _aliases(shell)
    saliases = f'<aliases>\n{aliases}\n</aliases>'
    return f'<system_info>\n{ssys}\n{sshell}\n{saliases}\n</system_info>'

# %% ../nbs/00_core.ipynb 16
def get_pane(n, pid=None):
    "Get output from a tmux pane"
    cmd = ['tmux', 'capture-pane', '-p', '-S', f'-{n}']
    if pid: cmd += ['-t', pid]
    return co(cmd, text=True)

# %% ../nbs/00_core.ipynb 18
def get_panes(n):
    cid = co(['tmux', 'display-message', '-p', '#{pane_id}'], text=True).strip()
    pids = [p for p in co(['tmux', 'list-panes', '-F', '#{pane_id}'], text=True).splitlines()]        
    return '\n'.join(f"<pane id={p} {'active' if p==cid else ''}>{get_pane(n, p)}</pane>" for p in pids)        

# %% ../nbs/00_core.ipynb 21
def tmux_history_lim():
    lim = co(['tmux', 'display-message', '-p', '#{history-limit}'], text=True).strip()
    return int(lim) if lim.isdigit() else 3000


# %% ../nbs/00_core.ipynb 23
def get_history(n, pid='current'):
    try:
        if pid=='current': return get_pane(n)
        if pid=='all': return get_panes(n)
        return get_pane(n, pid)
    except subprocess.CalledProcessError: return None

# %% ../nbs/00_core.ipynb 25
def view(path:str, rng:tuple[int,int]=None, nums:bool=False):
    "View directory or file contents with optional line range and numbers"
    try:
        p = Path(path).expanduser().resolve()
        if not p.exists(): return f"Error: File not found: {p}"
        if p.is_dir(): return f"Directory contents of {p}:\n" + "\n".join([str(f) for f in p.glob("**/*") if not f.name.startswith(".")])
        
        lines = p.read_text().splitlines()
        if rng:
            s,e = rng
            if not (1 <= s <= len(lines)): return f"Error: Invalid start line {s}"
            if e != -1 and not (s <= e <= len(lines)): return f"Error: Invalid end line {e}"
            lines = lines[s-1:None if e==-1 else e]
            
        return "\n".join([f"{i+s-1:6d} â”‚ {l}" for i,l in enumerate(lines,1)] if nums else lines)
    except Exception as e: return f"Error viewing file: {str(e)}"

# %% ../nbs/00_core.ipynb 28
def rgrep(term:str, path:str='.', grep_args:str='')->str:
    "Perform recursive grep search for `term` in `path` with optional grep arguments"
    # Build grep command with additional arguments
    path = Path(path).expanduser().resolve()
    cmd = f"grep -r '{term}' {path} {grep_args}"
    return run(cmd, shell=True, capture_output=True, text=True).stdout

# %% ../nbs/00_core.ipynb 31
default_cfg = asdict(ShellSageConfig())
def get_opts(**opts):
    cfg = get_cfg()
    for k, v in opts.items():
        if v is None: opts[k] = cfg.get(k, default_cfg.get(k))
    return AttrDict(opts)

# %% ../nbs/00_core.ipynb 33
clis = {
    'anthropic': cla.Client,
    'openai': cos.Client
}
chats = {
    'anthropic': cla.Chat,
    'openai': cos.Chat
}
sps = {
    'default': sp,
    'command': csp,
    'sassy': ssp,
    'deep_search': dssp
}
def get_sage(provider, model, base_url=None, api_key=None, mode='default'):
    if mode == 'deep_search':
        if base_url:
            return chats[provider](model, sp=sps[mode], 
                                   cli=OpenAI(base_url=base_url, api_key=api_key))
        else: return chats[provider](model, tools=[rgrep, view], sp=sps[mode])
    else:
        if base_url:
            cli = clis[provider](model, cli=OpenAI(base_url=base_url, api_key=api_key))
        else: cli = clis[provider](model)
        return partial(cli, sp=sps[mode])

# %% ../nbs/00_core.ipynb 40
conts = {
    'anthropic': cla.contents,
    'openai': cos.contents
}
p = r'```(?:bash\n|\n)?([^`]+)```'
def get_res(sage, q, provider, mode='default'):
    if mode == 'command':
        res = conts[provider](sage(q))
        return re.search(p, res).group(1).strip()
    elif mode == 'deep_search':
        return conts[provider](sage.toolloop(q))
    else: return conts[provider](sage(q))

# %% ../nbs/00_core.ipynb 45
class Log: id:int; timestamp:str; query:str; response:str; model:str; mode:str

log_path = Path("~/.shell_sage/logs/").expanduser()
def mk_db():
    log_path.mkdir(parents=True, exist_ok=True)
    db = database(log_path / "logs.db")
    db.logs = db.create(Log)
    return db

# %% ../nbs/00_core.ipynb 48
@call_parse
def main(
    query: Param('The query to send to the LLM', str, nargs='+'),
    v: Param("Print version", action='version') = '%(prog)s ' + __version__,
    pid: str = 'current',  # `current`, `all` or tmux pane_id (e.g. %0) for context
    skip_system: bool = False,  # Whether to skip system information in the AI's context
    history_lines: int = None,  # Number of history lines. Defaults to tmux scrollback history length
    s: bool = False,  # Enable sassy mode
    c: bool = False,  # Enable command mode
    ds: bool = True,  # Enable deep search mode
    log: bool = False,  # Enable logging
    provider: str = None,  # The LLM Provider
    model: str = None,  # The LLM model that will be invoked on the LLM provider
    base_url: str = None,
    api_key: str = None,
    code_theme: str = None,  # The code theme to use when rendering ShellSage's responses
    code_lexer: str = None,  # The lexer to use for inline code markdown blocks
    verbosity: int = 0  # Level of verbosity (0 or 1)
):
    opts = get_opts(history_lines=history_lines, provider=provider, model=model,
                    base_url=base_url, api_key=api_key, code_theme=code_theme,
                    code_lexer=code_lexer, log=log)

    mode = 'default'
    if s: mode = 'sassy'
    if c:
        if os.environ.get('TMUX') is None:
            raise Exception('Must be in a tmux session to use command mode.')
        mode = 'command'
    if ds: mode = 'deep_search'

    if verbosity > 0: print(f"{datetime.now()} | Starting ShellSage request with options {opts}")
    
    md = partial(Markdown, code_theme=opts.code_theme, inline_code_lexer=opts.code_lexer,
                 inline_code_theme=opts.code_theme)
    query = ' '.join(query)
    ctxt = '' if skip_system else _sys_info()

    # Get tmux history if in a tmux session
    if os.environ.get('TMUX'):
        if verbosity > 0: print(f"{datetime.now()} | Adding TMUX history to prompt")
        if opts.history_lines is None or opts.history_lines < 0:
            opts.history_lines = tmux_history_lim()
        history = get_history(opts.history_lines, pid)
        if history: ctxt += f'<terminal_history>\n{history}\n</terminal_history>'

    # Read from stdin if available
    if not sys.stdin.isatty():
        if verbosity > 0: print(f"{datetime.now()} | Adding stdin to prompt")
        ctxt += f'\n<context>\n{sys.stdin.read()}</context>'
    
    if verbosity > 0: print(f"{datetime.now()} | Finalizing prompt")

    query = f'{ctxt}\n<query>\n{query}\n</query>'
    query = [mk_msg(query)] if opts.provider == 'openai' else query

    if verbosity > 0:
        print(f"{datetime.now()} | Sending prompt to model")

    sage = get_sage(opts.provider, opts.model, opts.base_url, opts.api_key, mode)
    res = get_res(sage, query, opts.provider, mode=mode)
    
    # Handle logging if the log flag is set
    if opts.log:
        db = mk_db()
        db.logs.insert(Log(timestamp=datetime.now().isoformat(), query=query,
                           response=res, model=opts.model, mode=mode))

    if c: co(['tmux', 'send-keys', res], text=True)
    else: print(md(res))
